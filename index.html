<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>WASSII BILLIARD CLOCK</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <style>
    :root {
      --bg: #101010;
      --panel: #202020;
      --panel-active: #2d4a2d;
      --panel-finished: #4a2020;
      --text-main: #f5f5f5;
      --accent: #3fa34d;
      --danger: #c0392b;
      --overtime: #aa6f00;
      --time-size: 80px;    /* メインTIME（JSで上書き） */
      --score-size: 48px;   /* スコア数字（JSで上書き） */
      --label-size: 14px;   /* TIME / SCORE ラベル（JSで上書き） */
    }

    * { box-sizing: border-box; }

    html { height: 100%; }

    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      overflow-y: auto;
    }

    .app {
      flex: 1;
      width: 100%;
      margin: 0;
      display: flex;
      flex-direction: column;
      gap: 6px;
      height: 100%;
      padding: 14px 4px 4px;
    }

    @supports (padding: max(0px)) {
      .app {
        padding-top: max(14px, env(safe-area-inset-top));
        padding-right: max(4px, env(safe-area-inset-right));
        padding-bottom: max(4px, env(safe-area-inset-bottom));
        padding-left: max(4px, env(safe-area-inset-left));
      }
    }

    .clocks {
      display: flex;
      gap: 6px;
      flex: 1 1 auto;
      min-height: 0;
    }

    .clock {
      flex: 1;
      background: var(--panel);
      border-radius: 12px;
      padding: 8px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      align-items: stretch;
      cursor: pointer;
      user-select: none;
      touch-action: manipulation;
      box-shadow: 0 0 0 2px #000;
      transition: background 0.15s, transform 0.05s, box-shadow 0.15s;
      min-height: 0;
    }

    .clock:active {
      transform: scale(0.98);
      box-shadow: 0 0 0 2px var(--accent);
    }

    .clock.active {
      background: var(--panel-active);
      box-shadow: 0 0 0 3px var(--accent);
    }

    .clock.overtime {
      box-shadow: 0 0 0 3px var(--overtime);
    }

    .clock.finished {
      background: var(--panel-finished);
      box-shadow: 0 0 0 3px var(--danger);
    }

    .player-label {
      font-size: clamp(1.6rem, 3.0vw, 2.2rem);
      font-weight: 600;
      opacity: 0.9;
      letter-spacing: 0.10em;
      border-bottom: 1px dashed rgba(255, 255, 255, 0.35);
      padding-bottom: 4px;
      margin-bottom: 4px;
      outline: none;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .field-caption {
      font-size: var(--label-size);
      font-weight: 500;
      opacity: 0.8;
      letter-spacing: 0.20em;
      text-align: center;
      margin-top: 2px;
      margin-bottom: 2px;
    }

    .clock.overtime .field-caption {
      color: var(--overtime);
      opacity: 0.9;
    }

    .time-block {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
      margin-top: 2px;
    }

    .time {
      font-size: var(--time-size);
      font-weight: 600;
      text-align: center;
      margin: 0;
      line-height: 1.1;
    }

    .score-block {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-top: 2px;
    }

    .score-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      margin-top: 4px;
    }

    .score {
      font-size: var(--score-size);
      min-width: 2.4em;
      text-align: center;
      font-weight: 600;
    }

    .score-btn {
      font-size: clamp(2.0rem, 3.6vw, 2.6rem);
      padding: 10px 16px;
      border-radius: 999px;
      border: none;
      background: #333;
      color: var(--text-main);
      cursor: pointer;
      touch-action: manipulation;
      min-width: 60px;
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .score-btn:active {
      transform: scale(0.95);
      background: #444;
    }

    .controls {
      flex: 0 0 auto;
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-top: 2px;
    }

    .time-settings {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 14px;
      flex-wrap: wrap;
      font-size: 0.95rem;
    }

    .time-settings-side {
      display: flex;
      align-items: center;
      gap: 6px;
      min-width: 120px;
      justify-content: center;
    }

    .time-settings-label {
      opacity: 0.85;
      font-weight: 500;
      min-width: 2.5em;
      text-align: right;
    }

    .time-settings-value {
      font-size: 1.3rem;
      min-width: 2.4em;
      text-align: center;
    }

    .time-settings-main-label {
      font-size: 0.95rem;
      opacity: 0.9;
      letter-spacing: 0.15em;
      text-align: center;
      white-space: nowrap;
    }

    .small-btn {
      font-size: 1.1rem;
      padding: 4px 10px;
      border-radius: 999px;
      border: none;
      background: #333;
      color: var(--text-main);
      cursor: pointer;
      touch-action: manipulation;
    }

    .small-btn:active {
      transform: scale(0.96);
      background: #444;
    }

    .main-buttons {
      display: flex;
      gap: 8px;
      justify-content: center;
    }

    .main-buttons button {
      flex: 1;
      max-width: 220px;
      font-size: 1.1rem;
      padding: 10px 16px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      touch-action: manipulation;
    }

    #pauseBtn {
      background: #555;
      color: #fff;
    }

    #pauseBtn:active {
      transform: scale(0.97);
      filter: brightness(1.1);
    }

    #resetBtn {
      background: #444;
      color: #fff;
    }

    #resetBtn:active {
      transform: scale(0.97);
      filter: brightness(1.1);
    }

    .settings-btn {
      background: #333;
      color: #f5f5f5;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      opacity: 0.9;
    }

    .settings-btn span.icon {
      font-size: 1.1rem;
    }

    .settings-btn:active {
      transform: scale(0.97);
      background: #444;
    }

    @media (max-width: 700px) {
      .clocks {
        flex-direction: column;
      }
      .clock {
        min-height: 40vh;
      }
    }

    /* ===== 設定モーダル ===== */
    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.65);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .modal.open { display: flex; }

    .modal-content {
      background: #181818;
      border-radius: 12px;
      padding: 14px 16px 12px;
      width: min(420px, 92vw);
      box-shadow: 0 0 0 2px #000;
      font-size: 0.95rem;
    }

    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
    }

    .modal-title {
      font-size: 1.05rem;
      font-weight: 600;
    }

    .modal-close {
      border: none;
      background: transparent;
      color: #ccc;
      font-size: 1.2rem;
      cursor: pointer;
      padding: 0 4px;
    }

    .modal-section {
      border-top: 1px solid #333;
      padding-top: 8px;
      margin-top: 8px;
    }

    .modal-section:first-of-type {
      border-top: none;
      padding-top: 0;
      margin-top: 0;
    }

    .modal-section-title {
      font-size: 0.95rem;
      font-weight: 600;
      margin-bottom: 6px;
      opacity: 0.9;
    }

    .modal-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin: 4px 0;
    }

    .modal-row-label {
      opacity: 0.9;
      font-size: 0.92rem;
    }

    .modal-switch {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      font-size: 0.9rem;
    }

    .modal-switch input {
      width: 18px;
      height: 18px;
    }

    .shot-settings {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .shot-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .shot-row-label {
      min-width: 5em;
      opacity: 0.9;
    }

    .shot-row-controls {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .shot-display {
      min-width: 2.4em;
      text-align: center;
      font-size: 1.1rem;
    }

    .shot-btn {
      font-size: 1rem;
      padding: 3px 9px;
      border-radius: 999px;
      border: none;
      background: #333;
      color: var(--text-main);
      cursor: pointer;
      touch-action: manipulation;
    }

    .shot-btn:active {
      transform: scale(0.96);
      background: #444;
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="clocks">
      <div class="clock" data-player="A" id="clockA">
        <div class="player-label" contenteditable="true">PLAYER 1</div>

        <div class="time-block">
          <div class="field-caption">TIME</div>
          <div class="time" id="timeA">20:00</div>
        </div>

        <div class="score-block">
          <div class="field-caption">SCORE</div>
          <div class="score-row">
            <button class="score-btn" data-player="A" data-delta="-1">-</button>
            <div class="score" id="scoreA">0</div>
            <button class="score-btn" data-player="A" data-delta="1">+</button>
          </div>
        </div>
      </div>

      <div class="clock" data-player="B" id="clockB">
        <div class="player-label" contenteditable="true">PLAYER 2</div>

        <div class="time-block">
          <div class="field-caption">TIME</div>
          <div class="time" id="timeB">20:00</div>
        </div>

        <div class="score-block">
          <div class="field-caption">SCORE</div>
          <div class="score-row">
            <button class="score-btn" data-player="B" data-delta="-1">-</button>
            <div class="score" id="scoreB">0</div>
            <button class="score-btn" data-player="B" data-delta="1">+</button>
          </div>
        </div>
      </div>
    </div>

    <div class="controls">
      <div class="time-settings">
        <div class="time-settings-side">
          <span class="time-settings-label">P1</span>
          <button class="small-btn" id="minutesMinusA">-</button>
          <span class="time-settings-value" id="minutesDisplayA">20</span>
          <button class="small-btn" id="minutesPlusA">+</button>
        </div>

        <div class="time-settings-main-label">
          持ち時間（分）
        </div>

        <div class="time-settings-side">
          <span class="time-settings-label">P2</span>
          <button class="small-btn" id="minutesMinusB">-</button>
          <span class="time-settings-value" id="minutesDisplayB">20</span>
          <button class="small-btn" id="minutesPlusB">+</button>
        </div>
      </div>

      <div class="main-buttons">
        <button id="pauseBtn">一時停止</button>

        <button id="settingsBtn" class="settings-btn">
          <span class="icon">⚙</span><span>設定</span>
        </button>

        <button id="resetBtn">リセット</button>
      </div>
    </div>
  </div>

  <!-- 設定モーダル -->
  <div id="settingsModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">設定</div>
        <button class="modal-close" id="settingsCloseBtn">×</button>
      </div>

      <div class="modal-section">
        <div class="modal-section-title">サウンド</div>
        <div class="modal-row">
          <span class="modal-row-label">効果音</span>
          <label class="modal-switch">
            <input type="checkbox" id="soundToggle" checked>
            <span>サウンドを有効にする</span>
          </label>
        </div>
      </div>

      <div class="modal-section">
        <div class="modal-section-title">ショットクロック（秒）</div>
        <div class="shot-settings">
          <div class="shot-row">
            <span class="shot-row-label">P1 ショット</span>
            <div class="shot-row-controls">
              <button class="shot-btn" id="shotMinusA">-</button>
              <span class="shot-display" id="shotDisplayA">30</span>
              <button class="shot-btn" id="shotPlusA">+</button>
            </div>
          </div>
          <div class="shot-row">
            <span class="shot-row-label">P2 ショット</span>
            <div class="shot-row-controls">
              <button class="shot-btn" id="shotMinusB">-</button>
              <span class="shot-display" id="shotDisplayB">30</span>
              <button class="shot-btn" id="shotPlusB">+</button>
            </div>
          </div>
        </div>
      </div>

    </div>
  </div>

  <script>
    // ショットクロック秒数（P1 / P2）
    let overtimeSecondsA = 30;
    let overtimeSecondsB = 30;

    // デフォルト持ち時間（分）
    let initialMinutesA = 20;
    let initialMinutesB = 20;

    // 残り秒数
    let timeA = initialMinutesA * 60;
    let timeB = initialMinutesB * 60;
    let scoreA = 0;
    let scoreB = 0;

    let overtimeA = false;
    let overtimeB = false;
    let shotTimeA = overtimeSecondsA;
    let shotTimeB = overtimeSecondsB;

    let activePlayer = null;
    let timerId = null;
    let gameOver = false;
    let isPaused = false;

    let soundEnabled = true;

    const timeAEl = document.getElementById('timeA');
    const timeBEl = document.getElementById('timeB');
    const scoreAEl = document.getElementById('scoreA');
    const scoreBEl = document.getElementById('scoreB');
    const clockAEl = document.getElementById('clockA');
    const clockBEl = document.getElementById('clockB');

    const minutesDisplayAEl = document.getElementById('minutesDisplayA');
    const minutesDisplayBEl = document.getElementById('minutesDisplayB');
    const minutesPlusAEl = document.getElementById('minutesPlusA');
    const minutesMinusAEl = document.getElementById('minutesMinusA');
    const minutesPlusBEl = document.getElementById('minutesPlusB');
    const minutesMinusBEl = document.getElementById('minutesMinusB');

    const resetBtn = document.getElementById('resetBtn');
    const pauseBtn = document.getElementById('pauseBtn');

    const settingsBtn = document.getElementById('settingsBtn');
    const settingsModal = document.getElementById('settingsModal');
    const settingsCloseBtn = document.getElementById('settingsCloseBtn');
    const soundToggle = document.getElementById('soundToggle');

    const shotDisplayAEl = document.getElementById('shotDisplayA');
    const shotDisplayBEl = document.getElementById('shotDisplayB');
    const shotMinusAEl = document.getElementById('shotMinusA');
    const shotPlusAEl = document.getElementById('shotPlusA');
    const shotMinusBEl = document.getElementById('shotMinusB');
    const shotPlusBEl = document.getElementById('shotPlusB');

    // ===== ビープ音ユーティリティ =====
    let audioCtx = null;

    function ensureAudioCtx() {
      try {
        if (!audioCtx) {
          const AC = window.AudioContext || window.webkitAudioContext;
          if (AC) {
            audioCtx = new AC();
          }
        } else if (audioCtx.state === 'suspended') {
          audioCtx.resume();
        }
      } catch (e) {
        console.warn("audioCtx error:", e);
      }
    }

    function playBeep(freq = 1000, duration = 0.12, type = 'square', volume = 0.25) {
      if (!soundEnabled) return;
      if (!window.AudioContext && !window.webkitAudioContext) return;
      ensureAudioCtx();
      if (!audioCtx) return;

      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.type = type;
      osc.frequency.value = freq;
      gain.gain.value = volume;

      osc.connect(gain);
      gain.connect(audioCtx.destination);

      const now = audioCtx.currentTime;
      osc.start(now);
      osc.stop(now + duration);
    }

    function playOvertimeStartBeep() {
      playBeep(1000, 0.12);
      setTimeout(() => playBeep(1000, 0.12), 280);
      setTimeout(() => playBeep(1000, 0.12), 560);
    }

    function playShortCountdownBeep() {
      playBeep(1300, 0.07);
    }

    function playLongZeroBeep() {
      playBeep(900, 0.9, 'sine', 0.28);
    }

    function handleShotClockBeep(remaining) {
      if (remaining === 0) {
        playLongZeroBeep();
      } else if (remaining <= 10) {
        playShortCountdownBeep();
      }
    }

    // ===== フォントサイズ調整（パネル縦横から一発計算） =====
    function resizeFonts() {
      const appEl    = document.querySelector('.app');
      const clockEls = document.querySelectorAll('.clock');
      const timeEls  = document.querySelectorAll('.time');
      if (!appEl || clockEls.length === 0 || timeEls.length === 0) return;

      // まず基準サイズで描画してレイアウトを確定させる
      document.documentElement.style.setProperty('--time-size',  `80px`);
      document.documentElement.style.setProperty('--score-size', `48px`);
      document.documentElement.style.setProperty('--label-size', `14px`);

      requestAnimationFrame(() => {
        let minPanelW = Infinity;
        let minPanelH = Infinity;

        clockEls.forEach(clockEl => {
          const r = clockEl.getBoundingClientRect();
          if (r.width > 0 && r.height > 0) {
            minPanelW = Math.min(minPanelW, r.width);
            minPanelH = Math.min(minPanelH, r.height);
          }
        });

        if (!isFinite(minPanelW) || !isFinite(minPanelH)) return;

        // 「20:00」が収まるフォントサイズを計算
        const CHAR_COUNT = 5;   // "20:00"
        const CHAR_RATIO = 0.6; // 1文字 ≒ フォントサイズの0.6倍の幅
        const H_MARGIN   = 0.90; // 横方向はパネル幅の90%まで使う（左右5%余白）

        const maxTimeByWidth  =
          (minPanelW * H_MARGIN) / (CHAR_COUNT * CHAR_RATIO);
        const maxTimeByHeight = minPanelH * 0.60; // 高さ方向はパネルの60%まで

        let timeSize = Math.min(maxTimeByWidth, maxTimeByHeight);

        const MIN_TIME = 50;
        const MAX_TIME = 600;
        timeSize = Math.max(MIN_TIME, Math.min(MAX_TIME, timeSize));

        // スコア・ラベルは TIME 比率で決める
        let scoreSize = timeSize * 0.55;
        let labelSize = timeSize * 0.18;

        const MIN_SCORE = 30;
        const MAX_SCORE = 260;
        const MIN_LABEL = 12;
        const MAX_LABEL = 36;

        scoreSize = Math.max(MIN_SCORE, Math.min(MAX_SCORE, scoreSize));
        labelSize = Math.max(MIN_LABEL, Math.min(MAX_LABEL, labelSize));

        document.documentElement.style.setProperty('--time-size',  `${timeSize}px`);
        document.documentElement.style.setProperty('--score-size', `${scoreSize}px`);
        document.documentElement.style.setProperty('--label-size', `${labelSize}px`);
      });
    }

    function formatTime(sec) {
      const s = Math.max(0, Math.floor(sec));
      const m = Math.floor(s / 60);
      const r = s % 60;
      return m.toString().padStart(2, '0') + ':' + r.toString().padStart(2, '0');
    }

    function updateDisplays() {
      timeAEl.textContent = !overtimeA ? formatTime(timeA) : formatTime(shotTimeA);
      timeBEl.textContent = !overtimeB ? formatTime(timeB) : formatTime(shotTimeB);
      scoreAEl.textContent = scoreA.toString();
      scoreBEl.textContent = scoreB.toString();

      const finishedA = (!overtimeA && timeA === 0) || (overtimeA && shotTimeA === 0);
      const finishedB = (!overtimeB && timeB === 0) || (overtimeB && shotTimeB === 0);

      clockAEl.classList.toggle('finished', finishedA && gameOver);
      clockBEl.classList.toggle('finished', finishedB && gameOver);

      clockAEl.classList.toggle('overtime', overtimeA);
      clockBEl.classList.toggle('overtime', overtimeB);

      clockAEl.classList.remove('active');
      clockBEl.classList.remove('active');
      if (activePlayer === 'A') clockAEl.classList.add('active');
      else if (activePlayer === 'B') clockBEl.classList.add('active');
    }

    function clearTimer() {
      if (timerId !== null) {
        clearInterval(timerId);
        timerId = null;
      }
    }

    function startTimerLoop() {
      clearTimer();
      if (!activePlayer || gameOver || isPaused) return;

      timerId = setInterval(() => {
        if (gameOver || !activePlayer || isPaused) {
          clearTimer();
          return;
        }

        if (activePlayer === 'A') {
          if (!overtimeA) {
            if (timeA > 0) {
              timeA--;
              if (timeA <= 0) {
                timeA = 0;
                overtimeA = true;
                shotTimeA = overtimeSecondsA;
                playOvertimeStartBeep();
              }
            }
          } else if (shotTimeA > 0) {
            shotTimeA--;
            handleShotClockBeep(shotTimeA);
            if (shotTimeA <= 0) {
              shotTimeA = 0;
              gameOver = true;
              activePlayer = null;
              clearTimer();
            }
          }
        } else if (activePlayer === 'B') {
          if (!overtimeB) {
            if (timeB > 0) {
              timeB--;
              if (timeB <= 0) {
                timeB = 0;
                overtimeB = true;
                shotTimeB = overtimeSecondsB;
                playOvertimeStartBeep();
              }
            }
          } else if (shotTimeB > 0) {
            shotTimeB--;
            handleShotClockBeep(shotTimeB);
            if (shotTimeB <= 0) {
              shotTimeB = 0;
              gameOver = true;
              activePlayer = null;
              clearTimer();
            }
          }
        }

        updateDisplays();
      }, 1000);
    }

    function resetAll() {
      clearTimer();
      timeA = initialMinutesA * 60;
      timeB = initialMinutesB * 60;
      scoreA = 0;
      scoreB = 0;
      overtimeA = false;
      overtimeB = false;
      shotTimeA = overtimeSecondsA;
      shotTimeB = overtimeSecondsB;
      activePlayer = null;
      gameOver = false;
      isPaused = false;
      pauseBtn.textContent = '一時停止';
      updateDisplays();
    }

    // ターン交代時のショットクロック表示リセット
    function switchTurn() {
      if (!activePlayer || gameOver) return;

      // 打っていた側を満タンに戻す
      if (activePlayer === 'A' && overtimeA) {
        shotTimeA = overtimeSecondsA;
      } else if (activePlayer === 'B' && overtimeB) {
        shotTimeB = overtimeSecondsB;
      }

      // アクティブ交代
      activePlayer = activePlayer === 'A' ? 'B' : 'A';

      // 新アクティブ側もオーバータイムなら満タンから
      if (activePlayer === 'A' && overtimeA) {
        shotTimeA = overtimeSecondsA;
      } else if (activePlayer === 'B' && overtimeB) {
        shotTimeB = overtimeSecondsB;
      }

      updateDisplays();
    }

    function handleClockClick(player) {
      if (gameOver || isPaused) return;

      ensureAudioCtx();

      if (activePlayer === null && timerId === null) {
        activePlayer = player;
        if (activePlayer === 'A' && overtimeA) shotTimeA = overtimeSecondsA;
        else if (activePlayer === 'B' && overtimeB) shotTimeB = overtimeSecondsB;
        updateDisplays();
        startTimerLoop();
        return;
      }

      if (activePlayer === player) {
        switchTurn();
      }
    }

    clockAEl.addEventListener('click', () => handleClockClick('A'));
    clockBEl.addEventListener('click', () => handleClockClick('B'));

    document.querySelectorAll('.score-btn').forEach(btn => {
      btn.addEventListener('click', e => {
        e.stopPropagation();
        const player = btn.dataset.player;
        const delta = parseInt(btn.dataset.delta, 10) || 0;
        if (player === 'A') scoreA = Math.max(0, scoreA + delta);
        else scoreB = Math.max(0, scoreB + delta);
        updateDisplays();
      });
    });

    function updateMinutesDisplay() {
      minutesDisplayAEl.textContent = initialMinutesA.toString();
      minutesDisplayBEl.textContent = initialMinutesB.toString();
    }

    function isGameStarted() {
      return (
        activePlayer !== null ||
        timerId !== null ||
        overtimeA || overtimeB ||
        gameOver
      );
    }

    function applyMinutesToClocksIfNotStarted() {
      if (!isGameStarted()) {
        timeA = initialMinutesA * 60;
        timeB = initialMinutesB * 60;
        updateDisplays();
      }
    }

    // 持ち時間＋−（P1）
    minutesPlusAEl.addEventListener('click', () => {
      if (initialMinutesA < 120) {
        initialMinutesA++;
        updateMinutesDisplay();
        applyMinutesToClocksIfNotStarted();
      }
    });

    minutesMinusAEl.addEventListener('click', () => {
      if (initialMinutesA > 1) {
        initialMinutesA--;
        updateMinutesDisplay();
        applyMinutesToClocksIfNotStarted();
      }
    });

    // 持ち時間＋−（P2）
    minutesPlusBEl.addEventListener('click', () => {
      if (initialMinutesB < 120) {
        initialMinutesB++;
        updateMinutesDisplay();
        applyMinutesToClocksIfNotStarted();
      }
    });

    minutesMinusBEl.addEventListener('click', () => {
      if (initialMinutesB > 1) {
        initialMinutesB--;
        updateMinutesDisplay();
        applyMinutesToClocksIfNotStarted();
      }
    });

    // 設定モーダル関連
    function syncSettingsUI() {
      soundToggle.checked = soundEnabled;
      shotDisplayAEl.textContent = overtimeSecondsA.toString();
      shotDisplayBEl.textContent = overtimeSecondsB.toString();
    }

    function openSettings() {
      syncSettingsUI();
      settingsModal.classList.add('open');
    }

    function closeSettings() {
      settingsModal.classList.remove('open');
    }

    settingsBtn.addEventListener('click', openSettings);
    settingsCloseBtn.addEventListener('click', closeSettings);

    settingsModal.addEventListener('click', (e) => {
      if (e.target === settingsModal) closeSettings();
    });

    soundToggle.addEventListener('change', () => {
      soundEnabled = soundToggle.checked;
    });

    function clampShotSeconds(sec) {
      const min = 10;
      const max = 90;
      return Math.max(min, Math.min(max, sec));
    }

    function applyShotChange(player, delta) {
      if (player === 'A') {
        overtimeSecondsA = clampShotSeconds(overtimeSecondsA + delta);
        shotDisplayAEl.textContent = overtimeSecondsA.toString();
      } else {
        overtimeSecondsB = clampShotSeconds(overtimeSecondsB + delta);
        shotDisplayBEl.textContent = overtimeSecondsB.toString();
      }

      if (!isGameStarted()) {
        shotTimeA = overtimeSecondsA;
        shotTimeB = overtimeSecondsB;
      }
    }

    shotPlusAEl.addEventListener('click', () => applyShotChange('A', 5));
    shotMinusAEl.addEventListener('click', () => applyShotChange('A', -5));
    shotPlusBEl.addEventListener('click', () => applyShotChange('B', 5));
    shotMinusBEl.addEventListener('click', () => applyShotChange('B', -5));

    // リセット
    resetBtn.addEventListener('click', () => {
      const ok = window.confirm('タイマーとスコアをすべてリセットします。\nよろしいですか？');
      if (ok) resetAll();
    });

    pauseBtn.addEventListener('click', () => {
      if (gameOver) return;
      if (!isPaused) {
        isPaused = true;
        clearTimer();
        pauseBtn.textContent = '再開';
      } else {
        isPaused = false;
        pauseBtn.textContent = '一時停止';
        if (activePlayer !== null) startTimerLoop();
      }
    });

    // プレイヤーネーム編集
    document.querySelectorAll('.player-label').forEach(label => {
      label.addEventListener('click', e => e.stopPropagation());
      label.addEventListener('touchstart', e => e.stopPropagation());
      label.addEventListener('keydown', e => {
        if (e.key === 'Enter') {
          e.preventDefault();
          label.blur();
        }
      });
    });

    window.addEventListener('resize', resizeFonts);
    window.addEventListener('orientationchange', resizeFonts);
    window.addEventListener('load', resizeFonts);

    // 初期化
    updateMinutesDisplay();
    resetAll();
    resizeFonts();
  </script>
</body>
</html>
